//grid of checkboxes are initialized at 15x15 with a random distribution (see initialization step)
//a new grid can be generated by the user (size limit 2-40)
//a newly created grid can be changed manually by clicking checkboxes or automatically with the populate button
//
//global variables include:
//  globalPixels: an array containing all the checkbox nodes, this is updated on generation (initial or user)
//  neighborNumbers: an array where the value at each index indicates the number of neighbors the corresponding box has
//  survivalNumbers: an array of numbers (input by user) that determines which checkboxes survive to the next frame
//  birthNumbers: an array of numbers that determines which dead checkboxes become alive next frame
//  autoFlag: a flag for whether the auto button is on or off (display next frame automatically when on)

function gridGenerate(gridSize){
  //deal with bad inputs
  if (!gridSize) gridSize = 15;
  gridSize = parseInt(gridSize);
  if (isNaN(gridSize)){
    throw new Error('input must be a number')
  }
  if (gridSize > 40){
    gridSize = 40;
  }
  if (gridSize < 2){
    gridSize = 2;
  }
  //if there is already a grid, remove it
  const outerContainer = document.querySelector('#outer');
  if (outerContainer.childNodes.length > 0){
    outerContainer.innerHTML = '';
  }
  //create the checkbox elements,add them to an array and append them to outerContainer
  let pixels = [];
  for (let i = 0; i < gridSize; i++){
    let rowContainer = document.createElement('div');
    rowContainer.classList.add('row');
    outerContainer.appendChild(rowContainer);
    for (let j = 0; j < gridSize; j++){
      let pixel = document.createElement('input');
      pixel.type = 'checkbox';
      let id = (i*gridSize) + j;
      pixel.id = id;
      rowContainer.appendChild(pixel);
      pixels.push(pixel);
    }
  }
  //return list of button elements
  return pixels;
}

//wipe the grid and turn some back on randomly
function gridPopulate(pixels, chance){
  if (!chance) chance = 0.15;
  for (let pixel of pixels){
    pixel.checked = false;
    let choice = Math.random();
    if (choice <= chance){
      pixel.checked = true;
    }
  }
}

function measureGrid(pixels){
  const gS = Math.sqrt(pixels.length); //gS stands for gridSize
  
  //reset neighborNumbers array
  neighborNumbers = [];
  for (let i = 0; i < pixels.length; i++){
    neighborNumbers.push(0)
  }
  //allowed values (since they are all stored in one contiguous array)
  let mapping = [
    -gS-1,-gS,-gS+1,
       -1,        1,
     gS-1, gS, gS+1
  ];
  //look thru the pixels, 
  //if it is checked add 1 to all the nearby pixels' mappings (if within the grid)
  for (let pixel of pixels){
    let id = parseInt(pixel.id);
    if (pixel.checked){
      for (let mapVal of mapping){
        let candidateIDX = id + mapVal;
        //out of bounds condition for above and below the grid
        if (candidateIDX < 0 || candidateIDX > pixels.length-1) continue;
        //out of bounds condition for left edge of the grid
        if (id % gS === 0){
          if (mapVal === -1 || mapVal === -gS-1 || mapVal === gS-1) continue;
        }
        //out of bounds condition for right edge of the grid
        if (id % gS === gS-1){
          if (mapVal === 1 || mapVal === -gS+1 || mapVal === gS+1) continue;
        }
        //this mapVal + id combination passed the out-of-bounds test, so increment its neighbor value
        neighborNumbers[candidateIDX]++
      }
    }
  }
  // return neighborNumbers;
}


function updateGrid(pixels){
  for (let i = 0; i < neighborNumbers.length; i++){
    if (pixels[i].checked){
      if (!survivalNumbers.includes(neighborNumbers[i])) pixels[i].checked = false;
    }else{
      if (birthNumbers.includes(neighborNumbers[i])) pixels[i].checked = true;
    }
  }
}

//every 500ms
function mainLoop(){
  if (autoFlag){
    measureGrid(globalPixels);
    updateGrid(globalPixels);
    setTimeout(mainLoop, 500);
  }
}

//grab elements
const nextButton = document.querySelector('#next');
const autoButton = document.querySelector('#auto');
const generateButton = document.querySelector('#generate');
const populateButton = document.querySelector('#populate');
const generateInput = document.querySelector('#generate-input');
const populateInput = document.querySelector('#populate-input');

const survivalRule = document.querySelectorAll('.survival-rule');
const birthRule = document.querySelectorAll('.birth-rule');

//global stuff
let neighborNumbers = [];
let survivalNumbers = [2,3];
let birthNumbers = [3];
let autoFlag = false;

//initialization
let globalPixels = gridGenerate(15);
gridPopulate(globalPixels);

document.addEventListener('DOMContentLoaded', function(){
  //buttons functionality
  //generate and populate buttons for the user to modify the grid
  generateButton.addEventListener('click', () => {globalPixels = gridGenerate(generateInput.value)});
  populateButton.addEventListener('click', () => {gridPopulate(globalPixels,populateInput.value)});
  //nextButton makes one step forward
  nextButton.addEventListener('click', () => {
    measureGrid(globalPixels);
    updateGrid(globalPixels);
  });
  //autoButton sets up an interval to display the next frame
  autoButton.addEventListener('click', () => {
    autoFlag = !autoFlag;
    mainLoop();
  });

  //change the rules when the ruleButtons are clicked
  for (let el of survivalRule){
    el.addEventListener('change', (event) => {
      const pressedButtonIdx = parseInt(event.target.id);
      const ruleIdx = survivalNumbers.indexOf(pressedButtonIdx);
      if (ruleIdx !== -1) {survivalNumbers.splice(ruleIdx, 1)}
      else {survivalNumbers.push(pressedButtonIdx)};
    });
  }
  for (let el of birthRule){
    el.addEventListener('change', (event) => {
      const pressedButtonIdx = parseInt(event.target.id);
      const ruleIdx = birthNumbers.indexOf(pressedButtonIdx);
      if (ruleIdx !== -1) {birthNumbers.splice(ruleIdx, 1)}
      else{birthNumbers.push(pressedButtonIdx)};
    });
  }
})